import{r as h,q as X,e as s,v as w,y as Z}from"./iframe-CFwUcJnX.js";import{b as oe,d as O,e as se,l as re,f as de,k as ce}from"./useFocusRing-BJvcf-le.js";import{$ as V,a as ue,b as ee,c as pe,d as me,e as be}from"./useField-Dv7Llc0p.js";import{$ as he,a as fe}from"./useToggleState-nkbrUmuB.js";import{V as ve}from"./VisuallyHidden-BU0Zanyp.js";import{I as ye}from"./Icon-DeLX8lrb.js";import{I as ge}from"./CheckIcon-C-3PeeWu.js";import"./index-CxiwmT52.js";import"./index-B85a9uKh.js";import"./useLabel-Cd9Ss8NS.js";import"./useFormReset-8uaf6KFn.js";import"./resolveResponsiveProps-BLCo0nz9.js";function xe(e,t,a){let r=V({...e,value:t.isSelected}),{isInvalid:o,validationErrors:n,validationDetails:d}=r.displayValidation,{labelProps:l,inputProps:m,isSelected:i,isPressed:c,isDisabled:u,isReadOnly:f}=he({...e,isInvalid:o},t,a);ue(e,r,a);let{isIndeterminate:x,isRequired:v,validationBehavior:I="aria"}=e;h.useEffect(()=>{a.current&&(a.current.indeterminate=!!x)});let{pressProps:y}=oe({isDisabled:u||f,onPress(){let{[ee]:S}=e,{commitValidation:le}=S||r;le()}});return{labelProps:O(l,y),inputProps:{...m,checked:i,"aria-required":v&&I==="aria"||void 0,required:v&&I==="native"},isSelected:i,isPressed:c,isDisabled:u,isReadOnly:f,isInvalid:o,validationErrors:n,validationDetails:d}}const te=new WeakMap;function Ie(e,t){let{isDisabled:a,name:r,validationBehavior:o="aria"}=e,{isInvalid:n,validationErrors:d,validationDetails:l}=t.displayValidation,{labelProps:m,fieldProps:i,descriptionProps:c,errorMessageProps:u}=pe({...e,labelElementType:"span",isInvalid:n,errorMessage:e.errorMessage||d});te.set(t,{name:r,descriptionId:c.id,errorMessageId:u.id,validationBehavior:o});let f=se(e,{labelable:!0}),{focusWithinProps:x}=re({onBlurWithin:e.onBlur,onFocusWithin:e.onFocus,onFocusWithinChange:e.onFocusChange});return{groupProps:O(f,{role:"group","aria-disabled":a||void 0,...i,...x}),labelProps:m,descriptionProps:c,errorMessageProps:u,isInvalid:n,validationErrors:d,validationDetails:l}}function ke(e,t,a){const r=fe({isReadOnly:e.isReadOnly||t.isReadOnly,isSelected:t.isSelected(e.value),onChange(y){y?t.addValue(e.value):t.removeValue(e.value),e.onChange&&e.onChange(y)}});let{name:o,descriptionId:n,errorMessageId:d,validationBehavior:l}=te.get(t);var m;l=(m=e.validationBehavior)!==null&&m!==void 0?m:l;let{realtimeValidation:i}=V({...e,value:r.isSelected,name:void 0,validationBehavior:"aria"}),c=h.useRef(me),u=()=>{t.setInvalid(e.value,i.isInvalid?i:c.current)};h.useEffect(u);let f=t.realtimeValidation.isInvalid?t.realtimeValidation:i,x=l==="native"?t.displayValidation:f;var v;let I=xe({...e,isReadOnly:e.isReadOnly||t.isReadOnly,isDisabled:e.isDisabled||t.isDisabled,name:e.name||o,isRequired:(v=e.isRequired)!==null&&v!==void 0?v:t.isRequired,validationBehavior:l,[ee]:{realtimeValidation:f,displayValidation:x,resetValidation:t.resetValidation,commitValidation:t.commitValidation,updateValidation(y){c.current=y,u()}}},r,a);return{...I,inputProps:{...I.inputProps,"aria-describedby":[e["aria-describedby"],t.isInvalid?d:null,n].filter(Boolean).join(" ")||void 0}}}function Ce(e={}){let[t,a]=de(e.value,e.defaultValue||[],e.onChange),r=!!e.isRequired&&t.length===0,o=h.useRef(new Map),n=V({...e,value:t}),d=n.displayValidation.isInvalid;var l;return{...n,value:t,setValue(i){e.isReadOnly||e.isDisabled||a(i)},isDisabled:e.isDisabled||!1,isReadOnly:e.isReadOnly||!1,isSelected(i){return t.includes(i)},addValue(i){e.isReadOnly||e.isDisabled||t.includes(i)||a(t.concat(i))},removeValue(i){e.isReadOnly||e.isDisabled||t.includes(i)&&a(t.filter(c=>c!==i))},toggleValue(i){e.isReadOnly||e.isDisabled||(t.includes(i)?a(t.filter(c=>c!==i)):a(t.concat(i)))},setInvalid(i,c){let u=new Map(o.current);c.isInvalid?u.set(i,c):u.delete(i),o.current=u,n.updateValidation(be(...u.values()))},validationState:(l=e.validationState)!==null&&l!==void 0?l:d?"invalid":null,isInvalid:d,isRequired:r}}var _e="_1kcxloq0",$e="_1kcxloq1",Le="_1kcxloq2",we=X({defaultClassName:"_1kcxloq3 tq83zq0",variantClassNames:{},defaultVariants:{},compoundVariants:[]}),Oe="_1kcxloq4",Ve=X({defaultClassName:"_1kcxloq8 _1kcxloq7 onxwjuev onxwjudb onxwjulb onxwju73 onxwjup7 onxwjumz _1kcxloq6 _1kcxloq5",variantClassNames:{},defaultVariants:{},compoundVariants:[]});const ae=e=>{const t=h.useRef(null),a=h.useContext($),{inputProps:r,isSelected:o}=ke(e,a,t),{isFocusVisible:n,focusProps:d}=ce();return s.createElement("label",{className:we(),...w({"focus-visible":n})},s.createElement(ve,null,s.createElement("input",{...O(r,d),ref:t})),s.createElement("div",{className:Z({display:"flex",gap:"2",width:"full"})},s.createElement("div",{className:Ve(),...w({checked:o})},s.createElement(ye,{icon:ge})),s.createElement("div",{className:Oe},e.children)))};ae.displayName="OptionList.Item";const ie=({children:e,content:t})=>!e&&!t?null:s.createElement("div",{className:Z({display:"flex",gap:"2",justifyContent:"space-between"})},e??(t==null?void 0:t.map(a=>s.createElement("span",{key:a},a))));ie.displayName="OptionList.ItemSplitLabel";try{OptionList.Item.displayName="OptionList.Item",OptionList.Item.__docgenInfo={description:`The OptionListItem is used to populate OptionList. They are outlined with a large interactive area and flexible
label content layout.`,displayName:"OptionList.Item",props:{}}}catch{}try{OptionList.ItemSplitLabel.displayName="OptionList.ItemSplitLabel",OptionList.ItemSplitLabel.__docgenInfo={description:"Helper component part to display a checkbox button label with a second column justified to the end",displayName:"OptionList.ItemSplitLabel",props:{content:{defaultValue:null,description:"convenience prop for passing through a string array instead of children",name:"content",required:!1,type:{name:"string[]"}}}}}catch{}const $=h.createContext(null),p=e=>{const{children:t,className:a,description:r,label:o,ref:n,style:d}=e,l={ref:n,className:a,style:d},m=Ce(e),{groupProps:i,labelProps:c,descriptionProps:u}=Ie(e,m);return s.createElement("div",{...i,...l,...w({testid:e.testId})},s.createElement("div",{...c,className:$e},o),r&&s.createElement("div",{...u,className:Le},r),s.createElement($.Provider,{value:m},s.createElement("div",{className:_e},t)))};p.Item=ae;p.ItemSplitLabel=ie;try{$.displayName="OptionListContext",$.__docgenInfo={description:"",displayName:"OptionListContext",props:{}}}catch{}try{p.displayName="OptionList",p.__docgenInfo={description:"The OptionList is a form control that groups selectable items that apear as an outlined list of options and\nimplements React Aria `useCheckboxGroup`\n([docs](https://react-spectrum.adobe.com/react-aria/useCheckboxGroup.html))\n\nPopulate the OptionList group with the OptionListList, each item must have a `value` (unique) and be labelled.\nThe `value` of all active items are passed as a string array to set `defaultValue` (uncontrolled), `value`\n(controlled) and is the format returned from the onChange handler as well.\n\nUsed in the booking flow on the payment step for addons.\nFuture enhancements might include: validation states/error handling",displayName:"OptionList",props:{label:{defaultValue:null,description:"Label for the CheckboxButtons group needs to be provided at the component level for accessibility",name:"label",required:!0,type:{name:"ReactNode"}},description:{defaultValue:null,description:"A description for the field. Provides a hint such as specific requirements for what to choose.",name:"description",required:!1,type:{name:"ReactNode"}},children:{defaultValue:null,description:"Populate with one or more CheckboxItem components",name:"children",required:!1,type:{name:"ReactNode"}},name:{defaultValue:null,description:"The name of the input element, used when submitting an HTML form. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#htmlattrdefname).",name:"name",required:!1,type:{name:"string"}},defaultValue:{defaultValue:null,description:"The default value (uncontrolled).",name:"defaultValue",required:!1,type:{name:"string[]"}},value:{defaultValue:null,description:"Current selected value (controlled state)",name:"value",required:!1,type:{name:"string[]"}},onChange:{defaultValue:null,description:`Event handler when any checkbox button changes. Returned string array is the values of the inputs that are currently
checked.`,name:"onChange",required:!1,type:{name:"((value: string[]) => void)"}},testId:{defaultValue:null,description:"The test ID will be rendered as a data attribute on the element for e2e testing purposes",name:"testId",required:!1,type:{name:"string"}}}}}catch{}try{p.Item.displayName="OptionList.Item",p.Item.__docgenInfo={description:`The OptionListItem is used to populate OptionList. They are outlined with a large interactive area and flexible
label content layout.`,displayName:"OptionList.Item",props:{}}}catch{}try{p.ItemSplitLabel.displayName="OptionList.ItemSplitLabel",p.ItemSplitLabel.__docgenInfo={description:"Helper component part to display a checkbox button label with a second column justified to the end",displayName:"OptionList.ItemSplitLabel",props:{content:{defaultValue:null,description:"convenience prop for passing through a string array instead of children",name:"content",required:!1,type:{name:"string[]"}}}}}catch{}const{expect:b,fn:ne,getAllByRole:Se,within:Ee,userEvent:E}=__STORYBOOK_MODULE_TEST__,L=[["Tyre puncture repair","+28.00"],["Roadworthy certificate","+89.85"],["Re-gas air-conditioning","+99.00"],["Windscreen wipers - pair","+45.92"]],Pe={title:"Forms & Input Fields/Option List",component:p,args:{label:"Commonly requested extras",name:"extras",children:L.map((e,t)=>s.createElement(p.Item,{key:t,value:`${t}`},e[0])),testId:"demo-option-list",onChange:ne()},tags:["beta"]},k={play:async({args:e,canvasElement:t,step:a})=>{const o=Ee(t).getAllByRole("group")[0],n=Se(o,"checkbox");await a("Group renders label and attributes",async()=>{await b(o.firstChild).toHaveTextContent(`${e.label}`),await b(o).toHaveAttribute("data-testid",e.testId)}),await a("Checkboxes render labels and attributes",async()=>{for(const[d,l]of n.entries()){const m=l.closest("label");await b(m).toHaveTextContent(L[d][0]),await b(l).not.toBeChecked(),await b(l).toHaveAttribute("name",e.name),await b(l).toHaveAttribute("value",`${d}`)}}),await a("Checked states and onChange event",async()=>{for(const d of[0,2]){const l=n[d];await E.click(l,{delay:25}),await b(e.onChange).toHaveBeenCalled(),await b(l).toBeChecked()}}),await a("Keyboard interaction",async()=>{await E.keyboard("{Shift>}[Tab][Tab]{/Shift}[Space][Tab][Tab][Space]",{delay:25}),await b(e.onChange).toHaveBeenCalled(),await b(n[0]).not.toBeChecked(),await b(n[2]).not.toBeChecked()})}},g={args:{children:L.map((e,t)=>s.createElement(p.Item,{key:t,value:`${t}`},s.createElement(p.ItemSplitLabel,{content:e})))}},C={args:{...g.args,defaultValue:["1"]}},_={render:()=>{var r;const[e,t]=h.useState(["0","1","2","3"]),a=o=>{t(o),ne()};return s.createElement(p,{label:(r=Pe.args)==null?void 0:r.label,onChange:a,value:e},L.map((o,n)=>s.createElement(p.Item,{key:n,value:`${n}`},s.createElement(p.ItemSplitLabel,{content:o}))))}};var P,R,q,B,D;k.parameters={...k.parameters,docs:{...(P=k.parameters)==null?void 0:P.docs,source:{originalSource:`{
  play: async ({
    args,
    canvasElement,
    step
  }) => {
    const canvas = within(canvasElement);
    const group = canvas.getAllByRole('group')[0];
    const checkboxes = getAllByRole(group, 'checkbox');
    await step('Group renders label and attributes', async () => {
      await expect(group.firstChild).toHaveTextContent(\`\${args.label}\`);
      await expect(group).toHaveAttribute('data-testid', args.testId);
    });
    await step('Checkboxes render labels and attributes', async () => {
      for (const [idx, checkbox] of checkboxes.entries()) {
        const label = checkbox.closest('label');
        await expect(label).toHaveTextContent(itemData[idx][0]);
        await expect(checkbox).not.toBeChecked();
        await expect(checkbox).toHaveAttribute('name', args.name);
        await expect(checkbox).toHaveAttribute('value', \`\${idx}\`);
      }
    });
    await step('Checked states and onChange event', async () => {
      for (const idx of [0, 2]) {
        const checkbox = checkboxes[idx];
        await userEvent.click(checkbox, {
          delay: 25
        });
        await expect(args.onChange).toHaveBeenCalled();
        await expect(checkbox).toBeChecked();
      }
    });
    await step('Keyboard interaction', async () => {
      await userEvent.keyboard('{Shift>}[Tab][Tab]{/Shift}[Space][Tab][Tab][Space]', {
        delay: 25
      });
      await expect(args.onChange).toHaveBeenCalled();
      await expect(checkboxes[0]).not.toBeChecked();
      await expect(checkboxes[2]).not.toBeChecked();
    });
  }
}`,...(q=(R=k.parameters)==null?void 0:R.docs)==null?void 0:q.source},description:{story:"For simple content, map through the options, e.g.\n\n```\nitemData.map((item, idx) => (\n  <CheckboxButtons.Item key={idx} value={`${idx}`}>\n    {item[0]}\n  </CheckboxButtons.Item>\n))\n```",...(D=(B=k.parameters)==null?void 0:B.docs)==null?void 0:D.description}}};var N,T,H,M,A;g.parameters={...g.parameters,docs:{...(N=g.parameters)==null?void 0:N.docs,source:{originalSource:`{
  args: {
    children: itemData.map((data, idx) => <OptionList.Item key={idx} value={\`\${idx}\`}>
                <OptionList.ItemSplitLabel content={data} />
            </OptionList.Item>)
  }
}`,...(H=(T=g.parameters)==null?void 0:T.docs)==null?void 0:H.source},description:{story:"To acheive the the split-column layout in the checkbox label, use a CheckboxButtons.SplitLabel layout helper\ninside the CheckboxButtons.Item component. Currently supports text only. Populate the `content` prop on the SplitLabel\nwith a string array (content left, content right).",...(A=(M=g.parameters)==null?void 0:M.docs)==null?void 0:A.description}}};var j,F,W,G,z;C.parameters={...C.parameters,docs:{...(j=C.parameters)==null?void 0:j.docs,source:{originalSource:`{
  args: {
    ...SplitLabel.args,
    defaultValue: ['1']
  }
}`,...(W=(F=C.parameters)==null?void 0:F.docs)==null?void 0:W.source},description:{story:"The second option is checked by default, but the inputs are uncontrolled.",...(z=(G=C.parameters)==null?void 0:G.docs)==null?void 0:z.description}}};var K,U,Y,J,Q;_.parameters={..._.parameters,docs:{...(K=_.parameters)==null?void 0:K.docs,source:{originalSource:`{
  render: () => {
    const [currentValue, setCurrentValue] = useState<string[]>(['0', '1', '2', '3']);
    const handleOnChange = (values: string[]) => {
      setCurrentValue(values);
      fn();
    };
    return <OptionList label={meta.args?.label} onChange={handleOnChange} value={currentValue}>
                {itemData.map((data, idx) => <OptionList.Item key={idx} value={\`\${idx}\`}>
                        <OptionList.ItemSplitLabel content={data} />
                    </OptionList.Item>)}
            </OptionList>;
  }
}`,...(Y=(U=_.parameters)==null?void 0:U.docs)==null?void 0:Y.source},description:{story:`Controlled state with onChange handler. Each checkbox item must have a unique value because the state is handled as
an array of the selected values.`,...(Q=(J=_.parameters)==null?void 0:J.docs)==null?void 0:Q.description}}};const Ge=["Simple","SplitLabel","DefaultChecked","Controlled"];export{_ as Controlled,C as DefaultChecked,k as Simple,g as SplitLabel,Ge as __namedExportsOrder,Pe as default};
