import{r as x,e as o,C as V,s as E}from"./iframe-TtMUic4I.js";import{a as S,x as N}from"./useFocusable-C5F02sYK.js";import{$ as O,a as H,b as P,c as M,d as A,e as F}from"./useField-DXBd7XUc.js";import{$ as W,a as G}from"./usePress-Cs_tUIeL.js";import{$ as K,a as U}from"./useToggleState-OcvcvS9P.js";import{$ as z}from"./useFocusRing-D5bk4pUd.js";import{V as Y}from"./VisuallyHidden-x6dwBwaO.js";import{I as J}from"./Icon-CVCn9x6N.js";import{I as Q}from"./CheckIcon-DN0l2iSg.js";import{$ as X}from"./useFocusWithin-MgKZ0iwC.js";import"./preload-helper-PPVm8Dsz.js";import"./useLabel-ejgdazCP.js";import"./useLabels-DRgMt4EQ.js";import"./index-BkbnEq6Q.js";import"./index-CkMS7m0-.js";import"./useFormReset-hFB2Rw3p.js";import"./resolveResponsiveProps-Bf2dZkOp.js";function Z(e,t,a){let i=O({...e,value:t.isSelected}),{isInvalid:l,validationErrors:d,validationDetails:r}=i.displayValidation,{labelProps:s,inputProps:c,isSelected:m,isPressed:f,isDisabled:n,isReadOnly:u}=K({...e,isInvalid:l},t,a);H(e,i,a);let{isIndeterminate:h,isRequired:y,validationBehavior:g="aria"}=e;x.useEffect(()=>{a.current&&(a.current.indeterminate=!!h)});let{pressProps:_}=W({isDisabled:n||u,onPress(){let{[P]:v}=e,{commitValidation:T}=v||i;T()}});return{labelProps:S(s,_,x.useMemo(()=>({onMouseDown:v=>v.preventDefault()}),[])),inputProps:{...c,checked:m,"aria-required":y&&g==="aria"||void 0,required:y&&g==="native"},isSelected:m,isPressed:f,isDisabled:n,isReadOnly:u,isInvalid:l,validationErrors:d,validationDetails:r}}const q=new WeakMap;function ee(e,t){let{isDisabled:a,name:i,form:l,validationBehavior:d="aria"}=e,{isInvalid:r,validationErrors:s,validationDetails:c}=t.displayValidation,{labelProps:m,fieldProps:f,descriptionProps:n,errorMessageProps:u}=M({...e,labelElementType:"span",isInvalid:r,errorMessage:e.errorMessage||s});q.set(t,{name:i,form:l,descriptionId:n.id,errorMessageId:u.id,validationBehavior:d});let h=G(e,{labelable:!0}),{focusWithinProps:y}=X({onBlurWithin:e.onBlur,onFocusWithin:e.onFocus,onFocusWithinChange:e.onFocusChange});return{groupProps:S(h,{role:"group","aria-disabled":a||void 0,...f,...y}),labelProps:m,descriptionProps:n,errorMessageProps:u,isInvalid:r,validationErrors:s,validationDetails:c}}function te(e,t,a){const i=U({isReadOnly:e.isReadOnly||t.isReadOnly,isSelected:t.isSelected(e.value),defaultSelected:t.defaultValue.includes(e.value),onChange(v){v?t.addValue(e.value):t.removeValue(e.value),e.onChange&&e.onChange(v)}});let{name:l,form:d,descriptionId:r,errorMessageId:s,validationBehavior:c}=q.get(t);var m;c=(m=e.validationBehavior)!==null&&m!==void 0?m:c;let{realtimeValidation:f}=O({...e,value:i.isSelected,name:void 0,validationBehavior:"aria"}),n=x.useRef(A),u=()=>{t.setInvalid(e.value,f.isInvalid?f:n.current)};x.useEffect(u);let h=t.realtimeValidation.isInvalid?t.realtimeValidation:f,y=c==="native"?t.displayValidation:h;var g;let _=Z({...e,isReadOnly:e.isReadOnly||t.isReadOnly,isDisabled:e.isDisabled||t.isDisabled,name:e.name||l,form:e.form||d,isRequired:(g=e.isRequired)!==null&&g!==void 0?g:t.isRequired,validationBehavior:c,[P]:{realtimeValidation:h,displayValidation:y,resetValidation:t.resetValidation,commitValidation:t.commitValidation,updateValidation(v){n.current=v,u()}}},i,a);return{..._,inputProps:{..._.inputProps,"aria-describedby":[e["aria-describedby"],t.isInvalid?s:null,r].filter(Boolean).join(" ")||void 0}}}function ae(e={}){let[t,a]=N(e.value,e.defaultValue||[],e.onChange),[i]=x.useState(t),l=!!e.isRequired&&t.length===0,d=x.useRef(new Map),r=O({...e,value:t}),s=r.displayValidation.isInvalid;var c,m;return{...r,value:t,defaultValue:(c=e.defaultValue)!==null&&c!==void 0?c:i,setValue(n){e.isReadOnly||e.isDisabled||a(n)},isDisabled:e.isDisabled||!1,isReadOnly:e.isReadOnly||!1,isSelected(n){return t.includes(n)},addValue(n){e.isReadOnly||e.isDisabled||t.includes(n)||(t=t.concat(n),a(t))},removeValue(n){e.isReadOnly||e.isDisabled||t.includes(n)&&a(t.filter(u=>u!==n))},toggleValue(n){e.isReadOnly||e.isDisabled||(t.includes(n)?a(t.filter(u=>u!==n)):a(t.concat(n)))},setInvalid(n,u){let h=new Map(d.current);u.isInvalid?h.set(n,u):h.delete(n),d.current=h,r.updateValidation(F(...h.values()))},validationState:(m=e.validationState)!==null&&m!==void 0?m:s?"invalid":null,isInvalid:s,isRequired:l}}var ne="_1kcxloq0 onxwju11t",ie="_1kcxloq1 onxwjual onxwju9l onxwjuxx onxwju5m",oe="_1kcxloq3 _1kcxloq2 onxwjua9 onxwju99",le="_1kcxloq5 _1kcxloq4 onxwju19 onxwju1l onxwju1x onxwju29 onxwju2n onxwju2l onxwju2p onxwju2r onxwjucx onxwjuch onxwjudd onxwjudt onxwjuup onxwjuvt onxwjuwt onxwjuth onxwju6l onxwjui9 onxwju67 onxwjuh5 tq83zq0",re="_1kcxloq6 onxwjua5 onxwju95 onxwjunp onxwjuh5",se="_1kcxloq8 _1kcxloq7 onxwju2n onxwju2l onxwju2p onxwju2r onxwjucx onxwjuch onxwjudd onxwjudt onxwjugd onxwjuet onxwjumt onxwju6l onxwjuqp onxwjuoh onxwjubp";const R=e=>{const t=x.useRef(null),a=x.useContext(C),{inputProps:i,isSelected:l}=te(e,a,t),{isFocusVisible:d,focusProps:r}=z();return o.createElement("label",{className:le,...V({"focus-visible":d})},o.createElement(Y,null,o.createElement("input",{...S(i,r),ref:t})),o.createElement("div",{className:E({display:"flex",gap:"2",width:"full"})},o.createElement("div",{className:se,...V({checked:l})},o.createElement(J,{icon:Q})),o.createElement("div",{className:re},e.children)))};R.displayName="OptionList.Item";const B=({children:e,content:t})=>!e&&!t?null:o.createElement("div",{className:E({display:"flex",gap:"2",justifyContent:"space-between"})},e??t?.map(a=>o.createElement("span",{key:a},a)));B.displayName="OptionList.ItemSplitLabel";try{OptionList.Item.displayName="OptionList.Item",OptionList.Item.__docgenInfo={description:`The OptionListItem is used to populate OptionList. They are outlined with a large interactive area and flexible
label content layout.`,displayName:"OptionList.Item",props:{}}}catch{}try{OptionList.ItemSplitLabel.displayName="OptionList.ItemSplitLabel",OptionList.ItemSplitLabel.__docgenInfo={description:"Helper component part to display a checkbox button label with a second column justified to the end",displayName:"OptionList.ItemSplitLabel",props:{content:{defaultValue:null,description:"convenience prop for passing through a string array instead of children",name:"content",required:!1,type:{name:"string[]"}}}}}catch{}const C=x.createContext(null),p=e=>{const{children:t,className:a,description:i,label:l,ref:d,style:r}=e,s={ref:d,className:a,style:r},c=ae(e),{groupProps:m,labelProps:f,descriptionProps:n}=ee(e,c);return o.createElement("div",{...m,...s,...V({testid:e.testId})},o.createElement("div",{...f,className:ie},l),i&&o.createElement("div",{...n,className:oe},i),o.createElement(C.Provider,{value:c},o.createElement("div",{className:ne},t)))};p.Item=R;p.ItemSplitLabel=B;try{C.displayName="OptionListContext",C.__docgenInfo={description:"",displayName:"OptionListContext",props:{}}}catch{}try{p.displayName="OptionList",p.__docgenInfo={description:"The OptionList is a form control that groups selectable items that apear as an outlined list of options and\nimplements React Aria `useCheckboxGroup`\n([docs](https://react-spectrum.adobe.com/react-aria/useCheckboxGroup.html))\n\nPopulate the OptionList group with the OptionListList, each item must have a `value` (unique) and be labelled.\nThe `value` of all active items are passed as a string array to set `defaultValue` (uncontrolled), `value`\n(controlled) and is the format returned from the onChange handler as well.\n\nUsed in the booking flow on the payment step for addons.\nFuture enhancements might include: validation states/error handling",displayName:"OptionList",props:{label:{defaultValue:null,description:"Label for the CheckboxButtons group needs to be provided at the component level for accessibility",name:"label",required:!0,type:{name:"ReactNode"}},description:{defaultValue:null,description:"A description for the field. Provides a hint such as specific requirements for what to choose.",name:"description",required:!1,type:{name:"ReactNode"}},children:{defaultValue:null,description:"Populate with one or more CheckboxItem components",name:"children",required:!1,type:{name:"ReactNode"}},name:{defaultValue:null,description:"The name of the input element, used when submitting an HTML form. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#htmlattrdefname).",name:"name",required:!1,type:{name:"string"}},defaultValue:{defaultValue:null,description:"The default value (uncontrolled).",name:"defaultValue",required:!1,type:{name:"string[]"}},value:{defaultValue:null,description:"Current selected value (controlled state)",name:"value",required:!1,type:{name:"string[]"}},onChange:{defaultValue:null,description:`Event handler when any checkbox button changes. Returned string array is the values of the inputs that are currently
checked.`,name:"onChange",required:!1,type:{name:"((value: string[]) => void)"}},testId:{defaultValue:null,description:"The test ID will be rendered as a data attribute `data-testid` on the element for use with test assertions",name:"testId",required:!1,type:{name:"string"}}}}}catch{}try{p.Item.displayName="OptionList.Item",p.Item.__docgenInfo={description:`The OptionListItem is used to populate OptionList. They are outlined with a large interactive area and flexible
label content layout.`,displayName:"OptionList.Item",props:{}}}catch{}try{p.ItemSplitLabel.displayName="OptionList.ItemSplitLabel",p.ItemSplitLabel.__docgenInfo={description:"Helper component part to display a checkbox button label with a second column justified to the end",displayName:"OptionList.ItemSplitLabel",props:{content:{defaultValue:null,description:"convenience prop for passing through a string array instead of children",name:"content",required:!1,type:{name:"string[]"}}}}}catch{}const{expect:b,fn:D,getAllByRole:de,within:ce,userEvent:j}=__STORYBOOK_MODULE_TEST__,L=[["Tyre puncture repair","+28.00"],["Roadworthy certificate","+89.85"],["Re-gas air-conditioning","+99.00"],["Windscreen wipers - pair","+45.92"]],ue={title:"Forms & Input Fields/Option List",component:p,args:{label:"Commonly requested extras",name:"extras",children:L.map((e,t)=>o.createElement(p.Item,{key:t,value:`${t}`},e[0])),testId:"demo-option-list",onChange:D()},tags:["beta"]},I={play:async({args:e,canvasElement:t,step:a})=>{const l=ce(t).getAllByRole("group")[0],d=de(l,"checkbox");await a("Group renders label and attributes",async()=>{await b(l.firstChild).toHaveTextContent(`${e.label}`),await b(l).toHaveAttribute("data-testid",e.testId)}),await a("Checkboxes render labels and attributes",async()=>{for(const[r,s]of d.entries()){const c=s.closest("label");await b(c).toHaveTextContent(L[r][0]),await b(s).not.toBeChecked(),await b(s).toHaveAttribute("name",e.name),await b(s).toHaveAttribute("value",`${r}`)}}),await a("Checked states and onChange event",async()=>{for(const r of[0,2]){const s=d[r];await j.click(s,{delay:25}),await b(e.onChange).toHaveBeenCalled(),await b(s).toBeChecked()}}),await a("Keyboard interaction",async()=>{await j.keyboard("{Shift>}[Tab][Tab]{/Shift}[Space][Tab][Tab][Space]",{delay:25}),await b(e.onChange).toHaveBeenCalled(),await b(d[0]).not.toBeChecked(),await b(d[2]).not.toBeChecked()})}},w={args:{children:L.map((e,t)=>o.createElement(p.Item,{key:t,value:`${t}`},o.createElement(p.ItemSplitLabel,{content:e})))}},$={args:{...w.args,defaultValue:["1"]}},k={render:()=>{const[e,t]=x.useState(["0","1","2","3"]),a=i=>{t(i),D()};return o.createElement(p,{label:ue.args?.label,onChange:a,value:e},L.map((i,l)=>o.createElement(p.Item,{key:l,value:`${l}`},o.createElement(p.ItemSplitLabel,{content:i}))))}};I.parameters={...I.parameters,docs:{...I.parameters?.docs,source:{originalSource:`{
  play: async ({
    args,
    canvasElement,
    step
  }) => {
    const canvas = within(canvasElement);
    const group = canvas.getAllByRole('group')[0];
    const checkboxes = getAllByRole(group, 'checkbox');
    await step('Group renders label and attributes', async () => {
      await expect(group.firstChild).toHaveTextContent(\`\${args.label}\`);
      await expect(group).toHaveAttribute('data-testid', args.testId);
    });
    await step('Checkboxes render labels and attributes', async () => {
      for (const [idx, checkbox] of checkboxes.entries()) {
        const label = checkbox.closest('label');
        await expect(label).toHaveTextContent(itemData[idx][0]);
        await expect(checkbox).not.toBeChecked();
        await expect(checkbox).toHaveAttribute('name', args.name);
        await expect(checkbox).toHaveAttribute('value', \`\${idx}\`);
      }
    });
    await step('Checked states and onChange event', async () => {
      for (const idx of [0, 2]) {
        const checkbox = checkboxes[idx];
        await userEvent.click(checkbox, {
          delay: 25
        });
        await expect(args.onChange).toHaveBeenCalled();
        await expect(checkbox).toBeChecked();
      }
    });
    await step('Keyboard interaction', async () => {
      await userEvent.keyboard('{Shift>}[Tab][Tab]{/Shift}[Space][Tab][Tab][Space]', {
        delay: 25
      });
      await expect(args.onChange).toHaveBeenCalled();
      await expect(checkboxes[0]).not.toBeChecked();
      await expect(checkboxes[2]).not.toBeChecked();
    });
  }
}`,...I.parameters?.docs?.source},description:{story:"For simple content, map through the options, e.g.\n\n```\nitemData.map((item, idx) => (\n  <CheckboxButtons.Item key={idx} value={`${idx}`}>\n    {item[0]}\n  </CheckboxButtons.Item>\n))\n```",...I.parameters?.docs?.description}}};w.parameters={...w.parameters,docs:{...w.parameters?.docs,source:{originalSource:`{
  args: {
    children: itemData.map((data, idx) => <OptionList.Item key={idx} value={\`\${idx}\`}>
                <OptionList.ItemSplitLabel content={data} />
            </OptionList.Item>)
  }
}`,...w.parameters?.docs?.source},description:{story:"To acheive the the split-column layout in the checkbox label, use a CheckboxButtons.SplitLabel layout helper\ninside the CheckboxButtons.Item component. Currently supports text only. Populate the `content` prop on the SplitLabel\nwith a string array (content left, content right).",...w.parameters?.docs?.description}}};$.parameters={...$.parameters,docs:{...$.parameters?.docs,source:{originalSource:`{
  args: {
    ...SplitLabel.args,
    defaultValue: ['1']
  }
}`,...$.parameters?.docs?.source},description:{story:"The second option is checked by default, but the inputs are uncontrolled.",...$.parameters?.docs?.description}}};k.parameters={...k.parameters,docs:{...k.parameters?.docs,source:{originalSource:`{
  render: () => {
    const [currentValue, setCurrentValue] = useState<string[]>(['0', '1', '2', '3']);
    const handleOnChange = (values: string[]) => {
      setCurrentValue(values);
      fn();
    };
    return <OptionList label={meta.args?.label} onChange={handleOnChange} value={currentValue}>
                {itemData.map((data, idx) => <OptionList.Item key={idx} value={\`\${idx}\`}>
                        <OptionList.ItemSplitLabel content={data} />
                    </OptionList.Item>)}
            </OptionList>;
  }
}`,...k.parameters?.docs?.source},description:{story:`Controlled state with onChange handler. Each checkbox item must have a unique value because the state is handled as
an array of the selected values.`,...k.parameters?.docs?.description}}};const Se=["Simple","SplitLabel","DefaultChecked","Controlled"];export{k as Controlled,$ as DefaultChecked,I as Simple,w as SplitLabel,Se as __namedExportsOrder,ue as default};
