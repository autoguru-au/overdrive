import{f as Z,w as le,g as se,e as h,u as E}from"./index-B5B_0MNA.js";import{r as b,R as r}from"./index-Cr_cdoBq.js";import{d as _}from"./dataAttrs-BPvLuXwN.js";import{c as ee,o as j}from"./createRuntimeFn-62c9670f.esm-8KfOB316.js";import{b as re,c as L,d as de,n as ce,a as ue,m as pe}from"./useFocusRing-CjXZM1vs.js";import{$ as O,a as me,b as ae,c as he,d as be,e as fe}from"./useField-8l-YHZw-.js";import{$ as xe,a as ve}from"./useToggle-0DvcvVd_.js";import{V as ye}from"./VisuallyHidden-BIAOYn7J.js";import{I as ge}from"./Icon-DIjQuSIU.js";import{I as we}from"./CheckIcon-qb3DRtZd.js";import"./_commonjsHelpers-C932wzq6.js";import"./Box-BKM2iBhL.js";import"./useLabel-C1HY0sYj.js";import"./useFocusable-BMusqc3z.js";function Ie(e,a,t){let l=O({...e,value:a.isSelected}),{isInvalid:s,validationErrors:i,validationDetails:d}=l.displayValidation,{labelProps:o,inputProps:m,isSelected:n,isPressed:c,isDisabled:u,isReadOnly:f}=xe({...e,isInvalid:s},a,t);me(e,l,t);let{isIndeterminate:g,isRequired:x,validationBehavior:w="aria"}=e;b.useEffect(()=>{t.current&&(t.current.indeterminate=!!g)});let{pressProps:v}=re({isDisabled:u||f,onPress(){let{[ae]:S}=e,{commitValidation:oe}=S||l;oe()}});return{labelProps:L(o,v),inputProps:{...m,checked:n,"aria-required":x&&w==="aria"||void 0,required:x&&w==="native"},isSelected:n,isPressed:c,isDisabled:u,isReadOnly:f,isInvalid:s,validationErrors:i,validationDetails:d}}const te=new WeakMap;function ke(e,a){let{isDisabled:t,name:l,validationBehavior:s="aria"}=e,{isInvalid:i,validationErrors:d,validationDetails:o}=a.displayValidation,{labelProps:m,fieldProps:n,descriptionProps:c,errorMessageProps:u}=he({...e,labelElementType:"span",isInvalid:i,errorMessage:e.errorMessage||d});te.set(a,{name:l,descriptionId:c.id,errorMessageId:u.id,validationBehavior:s});let f=de(e,{labelable:!0}),{focusWithinProps:g}=ce({onBlurWithin:e.onBlur,onFocusWithin:e.onFocus,onFocusWithinChange:e.onFocusChange});return{groupProps:L(f,{role:"group","aria-disabled":t||void 0,...n,...g}),labelProps:m,descriptionProps:c,errorMessageProps:u,isInvalid:i,validationErrors:d,validationDetails:o}}function Ce(e,a,t){const l=ve({isReadOnly:e.isReadOnly||a.isReadOnly,isSelected:a.isSelected(e.value),onChange(v){v?a.addValue(e.value):a.removeValue(e.value),e.onChange&&e.onChange(v)}});let{name:s,descriptionId:i,errorMessageId:d,validationBehavior:o}=te.get(a);var m;o=(m=e.validationBehavior)!==null&&m!==void 0?m:o;let{realtimeValidation:n}=O({...e,value:l.isSelected,name:void 0,validationBehavior:"aria"}),c=b.useRef(be),u=()=>{a.setInvalid(e.value,n.isInvalid?n:c.current)};b.useEffect(u);let f=a.realtimeValidation.isInvalid?a.realtimeValidation:n,g=o==="native"?a.displayValidation:f;var x;let w=Ie({...e,isReadOnly:e.isReadOnly||a.isReadOnly,isDisabled:e.isDisabled||a.isDisabled,name:e.name||s,isRequired:(x=e.isRequired)!==null&&x!==void 0?x:a.isRequired,validationBehavior:o,[ae]:{realtimeValidation:f,displayValidation:g,resetValidation:a.resetValidation,commitValidation:a.commitValidation,updateValidation(v){c.current=v,u()}}},l,t);return{...w,inputProps:{...w.inputProps,"aria-describedby":[e["aria-describedby"],a.isInvalid?d:null,i].filter(Boolean).join(" ")||void 0}}}function $e(e={}){let[a,t]=ue(e.value,e.defaultValue||[],e.onChange),l=!!e.isRequired&&a.length===0,s=b.useRef(new Map),i=O({...e,value:a}),d=i.displayValidation.isInvalid;var o;return{...i,value:a,setValue(n){e.isReadOnly||e.isDisabled||t(n)},isDisabled:e.isDisabled||!1,isReadOnly:e.isReadOnly||!1,isSelected(n){return a.includes(n)},addValue(n){e.isReadOnly||e.isDisabled||a.includes(n)||t(a.concat(n))},removeValue(n){e.isReadOnly||e.isDisabled||a.includes(n)&&t(a.filter(c=>c!==n))},toggleValue(n){e.isReadOnly||e.isDisabled||(a.includes(n)?t(a.filter(c=>c!==n)):t(a.concat(n)))},setInvalid(n,c){let u=new Map(s.current);c.isInvalid?u.set(n,c):u.delete(n),s.current=u,i.updateValidation(fe(...u.values()))},validationState:(o=e.validationState)!==null&&o!==void 0?o:d?"invalid":null,isInvalid:d,isRequired:l}}var Ve="_1kcxloq0 onxwju19",_e="_1kcxloq1 onxwju2x onxwju3f onxwju3k onxwjuc",je="_1kcxloq2 onxwju2u onxwju3c onxwjurs",Le=ee({defaultClassName:"_1kcxloq5 _1kcxloq4 onxwju1r onxwju21 onxwju2a onxwju1g onxwju1dk onxwju13y onxwju13x onxwju1dn onxwju3w onxwjucc onxwjugk onxwju22u onxwju22j onxwjuj0 onxwju1 onxwju23s onxwju240 onxwju24o onxwju254 onxwju25h onxwjuow _1kcxloq3",variantClassNames:{},defaultVariants:{},compoundVariants:[]}),Oe=ee({defaultClassName:"_1kcxloq9 _1kcxloq8 onxwjuog onxwjun8 onxwjul0 onxwju1dk onxwju15e onxwju3w onxwju46 onxwjucc onxwju4c onxwjugk onxwju11c onxwju116 onxwjuj0 onxwjujo onxwjulg onxwju23s onxwju248 onxwju245 onxwju24o onxwju254 onxwju25h _1kcxloq7 _1kcxloq6",variantClassNames:{},defaultVariants:{},compoundVariants:[]});const ne=e=>{const a=b.useRef(null),t=b.useContext($),{inputProps:l,isSelected:s}=Ce(e,t,a),{isFocusVisible:i,focusProps:d}=pe();return r.createElement("label",{className:Le(),..._({"focus-visible":i})},r.createElement(ye,null,r.createElement("input",{...L(l,d),ref:a})),r.createElement("div",{className:j({display:"flex",gap:"2",width:"100%"})},r.createElement("div",{className:Oe(),..._({checked:s})},r.createElement(ge,{icon:we})),r.createElement("div",{className:j({alignSelf:"center",font:"sm",width:"100%"})},e.children)))};ne.displayName="OptionList.Item";const ie=({children:e,content:a})=>!e&&!a?null:r.createElement("div",{className:j({display:"flex",gap:"2",justifyContent:"space-between"})},e??(a==null?void 0:a.map((t,l)=>r.createElement("span",{key:l},t))));ie.displayName="OptionList.ItemSplitLabel";try{OptionList.Item.displayName="OptionList.Item",OptionList.Item.__docgenInfo={description:`The OptionListItem is used to populate OptionList. They are outlined with a large interactive area and flexible
label content layout.`,displayName:"OptionList.Item",props:{}}}catch{}const $=b.createContext(null),p=e=>{const{children:a,className:t,description:l,label:s,ref:i,style:d}=e,o={ref:i,className:t,style:d},m=$e(e),{groupProps:n,labelProps:c,descriptionProps:u}=ke(e,m);return r.createElement("div",{...n,...o,..._({"test-id":e.testId})},r.createElement("div",{...c,className:_e},s),l&&r.createElement("div",{...u,className:je},l),r.createElement($.Provider,{value:m},r.createElement("div",{className:Ve},a)))};p.Item=ne;p.ItemSplitLabel=ie;try{$.displayName="OptionListContext",$.__docgenInfo={description:"",displayName:"OptionListContext",props:{}}}catch{}try{p.displayName="OptionList",p.__docgenInfo={description:"The OptionList is a form control that groups selectable items that apear as an outlined list of options and\nimplements React Aria `useCheckboxGroup`\n([docs](https://react-spectrum.adobe.com/react-aria/useCheckboxGroup.html))\n\nPopulate the OptionList group with the OptionListList, each item must have a `value` (unique) and be labelled.\nThe `value` of all active items are passed as a string array to set `defaultValue` (uncontrolled), `value`\n(controlled) and is the format returned from the onChange handler as well.\n\nUsed in the booking flow on the payment step for addons.\nFuture enhancements might include: validation states/error handling",displayName:"OptionList",props:{label:{defaultValue:null,description:"Label for the CheckboxButtons group needs to be provided at the component level for accessibility",name:"label",required:!0,type:{name:"ReactNode"}},description:{defaultValue:null,description:"A description for the field. Provides a hint such as specific requirements for what to choose.",name:"description",required:!1,type:{name:"ReactNode"}},children:{defaultValue:null,description:"Populate with one or more CheckboxItem components",name:"children",required:!1,type:{name:"ReactNode"}},name:{defaultValue:null,description:"The name of the input element, used when submitting an HTML form. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#htmlattrdefname).",name:"name",required:!1,type:{name:"string"}},defaultValue:{defaultValue:null,description:"The default value (uncontrolled).",name:"defaultValue",required:!1,type:{name:"string[]"}},value:{defaultValue:null,description:"Current selected value (controlled state)",name:"value",required:!1,type:{name:"string[]"}},onChange:{defaultValue:null,description:`Event handler when any checkbox button changes. Returned string array is the values of the inputs that are currently
checked.`,name:"onChange",required:!1,type:{name:"((value: string[]) => void)"}},testId:{defaultValue:null,description:"The test ID will be rendered as a data attribute on the element for e2e testing purposes",name:"testId",required:!1,type:{name:"string"}}}}}catch{}try{p.Item.displayName="OptionList.Item",p.Item.__docgenInfo={description:`The OptionListItem is used to populate OptionList. They are outlined with a large interactive area and flexible
label content layout.`,displayName:"OptionList.Item",props:{}}}catch{}try{p.ItemSplitLabel.displayName="OptionList.ItemSplitLabel",p.ItemSplitLabel.__docgenInfo={description:"Helper component part to display a checkbox button label with a second column justified to the end",displayName:"OptionList.ItemSplitLabel",props:{content:{defaultValue:null,description:"convenience prop for passing through a string array instead of children",name:"content",required:!1,type:{name:"string[]"}}}}}catch{}const V=[["Tyre puncture repair","+28.00"],["Roadworthy certificate","+89.85"],["Re-gas air-conditioning","+99.00"],["Windscreen wipers - pair","+45.92"]],Se={title:"Forms & Input Fields/Option List",component:p,args:{label:"Commonly requested extras",name:"extras",children:V.map((e,a)=>r.createElement(p.Item,{key:a,value:`${a}`},e[0])),testId:"demo-option-list",onChange:Z()},tags:["beta"]},I={play:async({args:e,canvasElement:a,step:t})=>{const s=le(a).getAllByRole("group")[0],i=se(s,"checkbox");await t("Group renders label and attributes",async()=>{await h(s.firstChild).toHaveTextContent(`${e.label}`),await h(s).toHaveAttribute("data-test-id",e.testId)}),await t("Checkboxes render labels and attributes",async()=>{for(const[d,o]of i.entries()){const m=o.closest("label");await h(m).toHaveTextContent(V[d][0]),await h(o).not.toBeChecked(),await h(o).toHaveAttribute("name",e.name),await h(o).toHaveAttribute("value",`${d}`)}}),await t("Checked states and onChange event",async()=>{for(const d of[0,2]){const o=i[d];await E.click(o,{delay:25}),await h(e.onChange).toHaveBeenCalled(),await h(o).toBeChecked()}}),await t("Keyboard interaction",async()=>{await E.keyboard("{Shift>}[Tab][Tab]{/Shift}[Space][Tab][Tab][Space]",{delay:25}),await h(e.onChange).toHaveBeenCalled(),await h(i[0]).not.toBeChecked(),await h(i[2]).not.toBeChecked()})}},y={args:{children:V.map((e,a)=>r.createElement(p.Item,{key:a,value:`${a}`},r.createElement(p.ItemSplitLabel,{content:e})))}},k={args:{...y.args,defaultValue:["1"]}},C={render:()=>{var l;const[e,a]=b.useState(["0","1","2","3"]),t=s=>{a(s),Z()};return r.createElement(p,{label:(l=Se.args)==null?void 0:l.label,onChange:t,value:e},V.map((s,i)=>r.createElement(p.Item,{key:i,value:`${i}`},r.createElement(p.ItemSplitLabel,{content:s}))))}};var P,R,B,q,D;I.parameters={...I.parameters,docs:{...(P=I.parameters)==null?void 0:P.docs,source:{originalSource:`{
  play: async ({
    args,
    canvasElement,
    step
  }) => {
    const canvas = within(canvasElement);
    const group = canvas.getAllByRole('group')[0];
    const checkboxes = getAllByRole(group, 'checkbox');
    await step('Group renders label and attributes', async () => {
      await expect(group.firstChild).toHaveTextContent(\`\${args.label}\`);
      await expect(group).toHaveAttribute('data-test-id', args.testId);
    });
    await step('Checkboxes render labels and attributes', async () => {
      for (const [idx, checkbox] of checkboxes.entries()) {
        const label = checkbox.closest('label');
        await expect(label).toHaveTextContent(itemData[idx][0]);
        await expect(checkbox).not.toBeChecked();
        await expect(checkbox).toHaveAttribute('name', args.name);
        await expect(checkbox).toHaveAttribute('value', \`\${idx}\`);
      }
    });
    await step('Checked states and onChange event', async () => {
      for (const idx of [0, 2]) {
        const checkbox = checkboxes[idx];
        await userEvent.click(checkbox, {
          delay: 25
        });
        await expect(args.onChange).toHaveBeenCalled();
        await expect(checkbox).toBeChecked();
      }
    });
    await step('Keyboard interaction', async () => {
      await userEvent.keyboard('{Shift>}[Tab][Tab]{/Shift}[Space][Tab][Tab][Space]', {
        delay: 25
      });
      await expect(args.onChange).toHaveBeenCalled();
      await expect(checkboxes[0]).not.toBeChecked();
      await expect(checkboxes[2]).not.toBeChecked();
    });
  }
}`,...(B=(R=I.parameters)==null?void 0:R.docs)==null?void 0:B.source},description:{story:"For simple content, map through the options, e.g.\n\n```\nitemData.map((item, idx) => (\n  <CheckboxButtons.Item key={idx} value={`${idx}`}>\n    {item[0]}\n  </CheckboxButtons.Item>\n))\n```",...(D=(q=I.parameters)==null?void 0:q.docs)==null?void 0:D.description}}};var N,T,H,A,M;y.parameters={...y.parameters,docs:{...(N=y.parameters)==null?void 0:N.docs,source:{originalSource:`{
  args: {
    children: itemData.map((data, idx) => <OptionList.Item key={idx} value={\`\${idx}\`}>
                <OptionList.ItemSplitLabel content={data} />
            </OptionList.Item>)
  }
}`,...(H=(T=y.parameters)==null?void 0:T.docs)==null?void 0:H.source},description:{story:"To acheive the the split-column layout in the checkbox label, use a CheckboxButtons.SplitLabel layout helper\ninside the CheckboxButtons.Item component. Currently supports text only. Populate the `content` prop on the SplitLabel\nwith a string array (content left, content right).",...(M=(A=y.parameters)==null?void 0:A.docs)==null?void 0:M.description}}};var F,W,G,K,U;k.parameters={...k.parameters,docs:{...(F=k.parameters)==null?void 0:F.docs,source:{originalSource:`{
  args: {
    ...SplitLabel.args,
    defaultValue: ['1']
  }
}`,...(G=(W=k.parameters)==null?void 0:W.docs)==null?void 0:G.source},description:{story:"The second option is checked by default, but the inputs are uncontrolled.",...(U=(K=k.parameters)==null?void 0:K.docs)==null?void 0:U.description}}};var z,J,Q,X,Y;C.parameters={...C.parameters,docs:{...(z=C.parameters)==null?void 0:z.docs,source:{originalSource:`{
  render: () => {
    const [currentValue, setCurrentValue] = useState<string[]>(['0', '1', '2', '3']);
    const handleOnChange = (values: string[]) => {
      setCurrentValue(values);
      fn();
    };
    return <OptionList label={meta.args?.label} onChange={handleOnChange} value={currentValue}>
                {itemData.map((data, idx) => <OptionList.Item key={idx} value={\`\${idx}\`}>
                        <OptionList.ItemSplitLabel content={data} />
                    </OptionList.Item>)}
            </OptionList>;
  }
}`,...(Q=(J=C.parameters)==null?void 0:J.docs)==null?void 0:Q.source},description:{story:`Controlled state with onChange handler. Each checkbox item must have a unique value because the state is handled as
an array of the selected values.`,...(Y=(X=C.parameters)==null?void 0:X.docs)==null?void 0:Y.description}}};const Ke=["Simple","SplitLabel","DefaultChecked","Controlled"];export{C as Controlled,k as DefaultChecked,I as Simple,y as SplitLabel,Ke as __namedExportsOrder,Se as default};
