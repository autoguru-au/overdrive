import{r as b,C as P,e as s,z as L,y as R}from"./iframe-CB5JKjWu.js";import{b as M,d as O,e as A,l as j,f as F,k as W}from"./useFocusRing-BXORLLD5.js";import{$ as V,a as G,b as q,c as z,d as K,e as U}from"./useField-B1L6huZW.js";import{$ as Y,a as J}from"./useToggleState-3EZ8KlBw.js";import{V as Q}from"./VisuallyHidden-CNnqj1Z8.js";import{I as X}from"./Icon-CuUuZ0wo.js";import{I as Z}from"./CheckIcon-oR9D62Xo.js";import"./preload-helper-D9Z9MdNV.js";import"./index-BHNpTPOS.js";import"./index-KRHroF7l.js";import"./useLabel-CN4OBc6y.js";import"./useFormReset-Dm777UUv.js";import"./resolveResponsiveProps-CWYDc9O1.js";function ee(e,t,a){let l=V({...e,value:t.isSelected}),{isInvalid:o,validationErrors:r,validationDetails:d}=l.displayValidation,{labelProps:i,inputProps:m,isSelected:n,isPressed:c,isDisabled:u,isReadOnly:f}=Y({...e,isInvalid:o},t,a);G(e,l,a);let{isIndeterminate:x,isRequired:v,validationBehavior:I="aria"}=e;b.useEffect(()=>{a.current&&(a.current.indeterminate=!!x)});let{pressProps:y}=M({isDisabled:u||f,onPress(){let{[q]:S}=e,{commitValidation:H}=S||l;H()}});return{labelProps:O(i,y),inputProps:{...m,checked:n,"aria-required":v&&I==="aria"||void 0,required:v&&I==="native"},isSelected:n,isPressed:c,isDisabled:u,isReadOnly:f,isInvalid:o,validationErrors:r,validationDetails:d}}const B=new WeakMap;function te(e,t){let{isDisabled:a,name:l,validationBehavior:o="aria"}=e,{isInvalid:r,validationErrors:d,validationDetails:i}=t.displayValidation,{labelProps:m,fieldProps:n,descriptionProps:c,errorMessageProps:u}=z({...e,labelElementType:"span",isInvalid:r,errorMessage:e.errorMessage||d});B.set(t,{name:l,descriptionId:c.id,errorMessageId:u.id,validationBehavior:o});let f=A(e,{labelable:!0}),{focusWithinProps:x}=j({onBlurWithin:e.onBlur,onFocusWithin:e.onFocus,onFocusWithinChange:e.onFocusChange});return{groupProps:O(f,{role:"group","aria-disabled":a||void 0,...n,...x}),labelProps:m,descriptionProps:c,errorMessageProps:u,isInvalid:r,validationErrors:d,validationDetails:i}}function ae(e,t,a){const l=J({isReadOnly:e.isReadOnly||t.isReadOnly,isSelected:t.isSelected(e.value),onChange(y){y?t.addValue(e.value):t.removeValue(e.value),e.onChange&&e.onChange(y)}});let{name:o,descriptionId:r,errorMessageId:d,validationBehavior:i}=B.get(t);var m;i=(m=e.validationBehavior)!==null&&m!==void 0?m:i;let{realtimeValidation:n}=V({...e,value:l.isSelected,name:void 0,validationBehavior:"aria"}),c=b.useRef(K),u=()=>{t.setInvalid(e.value,n.isInvalid?n:c.current)};b.useEffect(u);let f=t.realtimeValidation.isInvalid?t.realtimeValidation:n,x=i==="native"?t.displayValidation:f;var v;let I=ee({...e,isReadOnly:e.isReadOnly||t.isReadOnly,isDisabled:e.isDisabled||t.isDisabled,name:e.name||o,isRequired:(v=e.isRequired)!==null&&v!==void 0?v:t.isRequired,validationBehavior:i,[q]:{realtimeValidation:f,displayValidation:x,resetValidation:t.resetValidation,commitValidation:t.commitValidation,updateValidation(y){c.current=y,u()}}},l,a);return{...I,inputProps:{...I.inputProps,"aria-describedby":[e["aria-describedby"],t.isInvalid?d:null,r].filter(Boolean).join(" ")||void 0}}}function ne(e={}){let[t,a]=F(e.value,e.defaultValue||[],e.onChange),l=!!e.isRequired&&t.length===0,o=b.useRef(new Map),r=V({...e,value:t}),d=r.displayValidation.isInvalid;var i;return{...r,value:t,setValue(n){e.isReadOnly||e.isDisabled||a(n)},isDisabled:e.isDisabled||!1,isReadOnly:e.isReadOnly||!1,isSelected(n){return t.includes(n)},addValue(n){e.isReadOnly||e.isDisabled||t.includes(n)||a(t.concat(n))},removeValue(n){e.isReadOnly||e.isDisabled||t.includes(n)&&a(t.filter(c=>c!==n))},toggleValue(n){e.isReadOnly||e.isDisabled||(t.includes(n)?a(t.filter(c=>c!==n)):a(t.concat(n)))},setInvalid(n,c){let u=new Map(o.current);c.isInvalid?u.set(n,c):u.delete(n),o.current=u,r.updateValidation(U(...u.values()))},validationState:(i=e.validationState)!==null&&i!==void 0?i:d?"invalid":null,isInvalid:d,isRequired:l}}var ie="_1kcxloq0",le="_1kcxloq1",oe="_1kcxloq2",se=P({defaultClassName:"_1kcxloq3 tq83zq0",variantClassNames:{},defaultVariants:{},compoundVariants:[]}),re="_1kcxloq4",de=P({defaultClassName:"_1kcxloq8 _1kcxloq7 onxwjugd onxwjuet onxwjumt onxwju6l onxwjuqp onxwjuoh _1kcxloq6 _1kcxloq5",variantClassNames:{},defaultVariants:{},compoundVariants:[]});const D=e=>{const t=b.useRef(null),a=b.useContext($),{inputProps:l,isSelected:o}=ae(e,a,t),{isFocusVisible:r,focusProps:d}=W();return s.createElement("label",{className:se(),...L({"focus-visible":r})},s.createElement(Q,null,s.createElement("input",{...O(l,d),ref:t})),s.createElement("div",{className:R({display:"flex",gap:"2",width:"full"})},s.createElement("div",{className:de(),...L({checked:o})},s.createElement(X,{icon:Z})),s.createElement("div",{className:re},e.children)))};D.displayName="OptionList.Item";const N=({children:e,content:t})=>!e&&!t?null:s.createElement("div",{className:R({display:"flex",gap:"2",justifyContent:"space-between"})},e??t?.map(a=>s.createElement("span",{key:a},a)));N.displayName="OptionList.ItemSplitLabel";try{OptionList.Item.displayName="OptionList.Item",OptionList.Item.__docgenInfo={description:`The OptionListItem is used to populate OptionList. They are outlined with a large interactive area and flexible
label content layout.`,displayName:"OptionList.Item",props:{}}}catch{}try{OptionList.ItemSplitLabel.displayName="OptionList.ItemSplitLabel",OptionList.ItemSplitLabel.__docgenInfo={description:"Helper component part to display a checkbox button label with a second column justified to the end",displayName:"OptionList.ItemSplitLabel",props:{content:{defaultValue:null,description:"convenience prop for passing through a string array instead of children",name:"content",required:!1,type:{name:"string[]"}}}}}catch{}const $=b.createContext(null),p=e=>{const{children:t,className:a,description:l,label:o,ref:r,style:d}=e,i={ref:r,className:a,style:d},m=ne(e),{groupProps:n,labelProps:c,descriptionProps:u}=te(e,m);return s.createElement("div",{...n,...i,...L({testid:e.testId})},s.createElement("div",{...c,className:le},o),l&&s.createElement("div",{...u,className:oe},l),s.createElement($.Provider,{value:m},s.createElement("div",{className:ie},t)))};p.Item=D;p.ItemSplitLabel=N;try{$.displayName="OptionListContext",$.__docgenInfo={description:"",displayName:"OptionListContext",props:{}}}catch{}try{p.displayName="OptionList",p.__docgenInfo={description:"The OptionList is a form control that groups selectable items that apear as an outlined list of options and\nimplements React Aria `useCheckboxGroup`\n([docs](https://react-spectrum.adobe.com/react-aria/useCheckboxGroup.html))\n\nPopulate the OptionList group with the OptionListList, each item must have a `value` (unique) and be labelled.\nThe `value` of all active items are passed as a string array to set `defaultValue` (uncontrolled), `value`\n(controlled) and is the format returned from the onChange handler as well.\n\nUsed in the booking flow on the payment step for addons.\nFuture enhancements might include: validation states/error handling",displayName:"OptionList",props:{label:{defaultValue:null,description:"Label for the CheckboxButtons group needs to be provided at the component level for accessibility",name:"label",required:!0,type:{name:"ReactNode"}},description:{defaultValue:null,description:"A description for the field. Provides a hint such as specific requirements for what to choose.",name:"description",required:!1,type:{name:"ReactNode"}},children:{defaultValue:null,description:"Populate with one or more CheckboxItem components",name:"children",required:!1,type:{name:"ReactNode"}},name:{defaultValue:null,description:"The name of the input element, used when submitting an HTML form. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#htmlattrdefname).",name:"name",required:!1,type:{name:"string"}},defaultValue:{defaultValue:null,description:"The default value (uncontrolled).",name:"defaultValue",required:!1,type:{name:"string[]"}},value:{defaultValue:null,description:"Current selected value (controlled state)",name:"value",required:!1,type:{name:"string[]"}},onChange:{defaultValue:null,description:`Event handler when any checkbox button changes. Returned string array is the values of the inputs that are currently
checked.`,name:"onChange",required:!1,type:{name:"((value: string[]) => void)"}},testId:{defaultValue:null,description:"The test ID will be rendered as a data attribute `data-testid` on the element for use with test assertions",name:"testId",required:!1,type:{name:"string"}}}}}catch{}try{p.Item.displayName="OptionList.Item",p.Item.__docgenInfo={description:`The OptionListItem is used to populate OptionList. They are outlined with a large interactive area and flexible
label content layout.`,displayName:"OptionList.Item",props:{}}}catch{}try{p.ItemSplitLabel.displayName="OptionList.ItemSplitLabel",p.ItemSplitLabel.__docgenInfo={description:"Helper component part to display a checkbox button label with a second column justified to the end",displayName:"OptionList.ItemSplitLabel",props:{content:{defaultValue:null,description:"convenience prop for passing through a string array instead of children",name:"content",required:!1,type:{name:"string[]"}}}}}catch{}const{expect:h,fn:T,getAllByRole:ce,within:ue,userEvent:E}=__STORYBOOK_MODULE_TEST__,w=[["Tyre puncture repair","+28.00"],["Roadworthy certificate","+89.85"],["Re-gas air-conditioning","+99.00"],["Windscreen wipers - pair","+45.92"]],pe={title:"Forms & Input Fields/Option List",component:p,args:{label:"Commonly requested extras",name:"extras",children:w.map((e,t)=>s.createElement(p.Item,{key:t,value:`${t}`},e[0])),testId:"demo-option-list",onChange:T()},tags:["beta"]},k={play:async({args:e,canvasElement:t,step:a})=>{const o=ue(t).getAllByRole("group")[0],r=ce(o,"checkbox");await a("Group renders label and attributes",async()=>{await h(o.firstChild).toHaveTextContent(`${e.label}`),await h(o).toHaveAttribute("data-testid",e.testId)}),await a("Checkboxes render labels and attributes",async()=>{for(const[d,i]of r.entries()){const m=i.closest("label");await h(m).toHaveTextContent(w[d][0]),await h(i).not.toBeChecked(),await h(i).toHaveAttribute("name",e.name),await h(i).toHaveAttribute("value",`${d}`)}}),await a("Checked states and onChange event",async()=>{for(const d of[0,2]){const i=r[d];await E.click(i,{delay:25}),await h(e.onChange).toHaveBeenCalled(),await h(i).toBeChecked()}}),await a("Keyboard interaction",async()=>{await E.keyboard("{Shift>}[Tab][Tab]{/Shift}[Space][Tab][Tab][Space]",{delay:25}),await h(e.onChange).toHaveBeenCalled(),await h(r[0]).not.toBeChecked(),await h(r[2]).not.toBeChecked()})}},g={args:{children:w.map((e,t)=>s.createElement(p.Item,{key:t,value:`${t}`},s.createElement(p.ItemSplitLabel,{content:e})))}},C={args:{...g.args,defaultValue:["1"]}},_={render:()=>{const[e,t]=b.useState(["0","1","2","3"]),a=l=>{t(l),T()};return s.createElement(p,{label:pe.args?.label,onChange:a,value:e},w.map((l,o)=>s.createElement(p.Item,{key:o,value:`${o}`},s.createElement(p.ItemSplitLabel,{content:l}))))}};k.parameters={...k.parameters,docs:{...k.parameters?.docs,source:{originalSource:`{
  play: async ({
    args,
    canvasElement,
    step
  }) => {
    const canvas = within(canvasElement);
    const group = canvas.getAllByRole('group')[0];
    const checkboxes = getAllByRole(group, 'checkbox');
    await step('Group renders label and attributes', async () => {
      await expect(group.firstChild).toHaveTextContent(\`\${args.label}\`);
      await expect(group).toHaveAttribute('data-testid', args.testId);
    });
    await step('Checkboxes render labels and attributes', async () => {
      for (const [idx, checkbox] of checkboxes.entries()) {
        const label = checkbox.closest('label');
        await expect(label).toHaveTextContent(itemData[idx][0]);
        await expect(checkbox).not.toBeChecked();
        await expect(checkbox).toHaveAttribute('name', args.name);
        await expect(checkbox).toHaveAttribute('value', \`\${idx}\`);
      }
    });
    await step('Checked states and onChange event', async () => {
      for (const idx of [0, 2]) {
        const checkbox = checkboxes[idx];
        await userEvent.click(checkbox, {
          delay: 25
        });
        await expect(args.onChange).toHaveBeenCalled();
        await expect(checkbox).toBeChecked();
      }
    });
    await step('Keyboard interaction', async () => {
      await userEvent.keyboard('{Shift>}[Tab][Tab]{/Shift}[Space][Tab][Tab][Space]', {
        delay: 25
      });
      await expect(args.onChange).toHaveBeenCalled();
      await expect(checkboxes[0]).not.toBeChecked();
      await expect(checkboxes[2]).not.toBeChecked();
    });
  }
}`,...k.parameters?.docs?.source},description:{story:"For simple content, map through the options, e.g.\n\n```\nitemData.map((item, idx) => (\n  <CheckboxButtons.Item key={idx} value={`${idx}`}>\n    {item[0]}\n  </CheckboxButtons.Item>\n))\n```",...k.parameters?.docs?.description}}};g.parameters={...g.parameters,docs:{...g.parameters?.docs,source:{originalSource:`{
  args: {
    children: itemData.map((data, idx) => <OptionList.Item key={idx} value={\`\${idx}\`}>
                <OptionList.ItemSplitLabel content={data} />
            </OptionList.Item>)
  }
}`,...g.parameters?.docs?.source},description:{story:"To acheive the the split-column layout in the checkbox label, use a CheckboxButtons.SplitLabel layout helper\ninside the CheckboxButtons.Item component. Currently supports text only. Populate the `content` prop on the SplitLabel\nwith a string array (content left, content right).",...g.parameters?.docs?.description}}};C.parameters={...C.parameters,docs:{...C.parameters?.docs,source:{originalSource:`{
  args: {
    ...SplitLabel.args,
    defaultValue: ['1']
  }
}`,...C.parameters?.docs?.source},description:{story:"The second option is checked by default, but the inputs are uncontrolled.",...C.parameters?.docs?.description}}};_.parameters={..._.parameters,docs:{..._.parameters?.docs,source:{originalSource:`{
  render: () => {
    const [currentValue, setCurrentValue] = useState<string[]>(['0', '1', '2', '3']);
    const handleOnChange = (values: string[]) => {
      setCurrentValue(values);
      fn();
    };
    return <OptionList label={meta.args?.label} onChange={handleOnChange} value={currentValue}>
                {itemData.map((data, idx) => <OptionList.Item key={idx} value={\`\${idx}\`}>
                        <OptionList.ItemSplitLabel content={data} />
                    </OptionList.Item>)}
            </OptionList>;
  }
}`,..._.parameters?.docs?.source},description:{story:`Controlled state with onChange handler. Each checkbox item must have a unique value because the state is handled as
an array of the selected values.`,..._.parameters?.docs?.description}}};const we=["Simple","SplitLabel","DefaultChecked","Controlled"];export{_ as Controlled,C as DefaultChecked,k as Simple,g as SplitLabel,we as __namedExportsOrder,pe as default};
