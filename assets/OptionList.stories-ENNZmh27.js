import{f as Y,w as le,g as se,e as h,u as R}from"./index-BvIx1Icx.js";import{r as b,R as s}from"./index-UyvCXs0Z.js";import{d as _}from"./dataAttrs-C4KudU4k.js";import"./Box-BZBbKvYV.js";import"./focusOutline.css.ts.vanilla-CAjzf48Q.js";import{c as Z}from"./createRuntimeFn-62c9670f.esm-BkdTE7RR.js";import{s as ee}from"./sprinkles.css-BtO0TI8T.js";import{a as re,c as L,d as de,l as ce,e as ue,k as pe}from"./useFocusRing-ZvCRST-B.js";import{$ as O,a as me,b as ae,c as he,d as be,e as fe}from"./useField-76yXiEug.js";import{$ as ve,a as ye}from"./useToggleState-u6PuBL9Z.js";import{V as ge}from"./VisuallyHidden-ByHnd5WU.js";import{I as xe}from"./Icon-DcPNnT7l.js";import{I as Ie}from"./CheckIcon-CoTLElTW.js";import"./_commonjsHelpers-gnU0ypJ3.js";import"./vanilla-extract-sprinkles-createRuntimeSprinkles.esm-gvoir1Kq.js";import"./index-ijGxv8TO.js";import"./index-rbvpFaDF.js";import"./useFormReset-DscqYaxq.js";function ke(e,a,t){let r=O({...e,value:a.isSelected}),{isInvalid:l,validationErrors:n,validationDetails:d}=r.displayValidation,{labelProps:o,inputProps:m,isSelected:i,isPressed:c,isDisabled:u,isReadOnly:f}=ve({...e,isInvalid:l},a,t);me(e,r,t);let{isIndeterminate:x,isRequired:v,validationBehavior:I="aria"}=e;b.useEffect(()=>{t.current&&(t.current.indeterminate=!!x)});let{pressProps:y}=re({isDisabled:u||f,onPress(){let{[ae]:S}=e,{commitValidation:oe}=S||r;oe()}});return{labelProps:L(o,y),inputProps:{...m,checked:i,"aria-required":v&&I==="aria"||void 0,required:v&&I==="native"},isSelected:i,isPressed:c,isDisabled:u,isReadOnly:f,isInvalid:l,validationErrors:n,validationDetails:d}}const te=new WeakMap;function Ce(e,a){let{isDisabled:t,name:r,validationBehavior:l="aria"}=e,{isInvalid:n,validationErrors:d,validationDetails:o}=a.displayValidation,{labelProps:m,fieldProps:i,descriptionProps:c,errorMessageProps:u}=he({...e,labelElementType:"span",isInvalid:n,errorMessage:e.errorMessage||d});te.set(a,{name:r,descriptionId:c.id,errorMessageId:u.id,validationBehavior:l});let f=de(e,{labelable:!0}),{focusWithinProps:x}=ce({onBlurWithin:e.onBlur,onFocusWithin:e.onFocus,onFocusWithinChange:e.onFocusChange});return{groupProps:L(f,{role:"group","aria-disabled":t||void 0,...i,...x}),labelProps:m,descriptionProps:c,errorMessageProps:u,isInvalid:n,validationErrors:d,validationDetails:o}}function $e(e,a,t){const r=ye({isReadOnly:e.isReadOnly||a.isReadOnly,isSelected:a.isSelected(e.value),onChange(y){y?a.addValue(e.value):a.removeValue(e.value),e.onChange&&e.onChange(y)}});let{name:l,descriptionId:n,errorMessageId:d,validationBehavior:o}=te.get(a);var m;o=(m=e.validationBehavior)!==null&&m!==void 0?m:o;let{realtimeValidation:i}=O({...e,value:r.isSelected,name:void 0,validationBehavior:"aria"}),c=b.useRef(be),u=()=>{a.setInvalid(e.value,i.isInvalid?i:c.current)};b.useEffect(u);let f=a.realtimeValidation.isInvalid?a.realtimeValidation:i,x=o==="native"?a.displayValidation:f;var v;let I=ke({...e,isReadOnly:e.isReadOnly||a.isReadOnly,isDisabled:e.isDisabled||a.isDisabled,name:e.name||l,isRequired:(v=e.isRequired)!==null&&v!==void 0?v:a.isRequired,validationBehavior:o,[ae]:{realtimeValidation:f,displayValidation:x,resetValidation:a.resetValidation,commitValidation:a.commitValidation,updateValidation(y){c.current=y,u()}}},r,t);return{...I,inputProps:{...I.inputProps,"aria-describedby":[e["aria-describedby"],a.isInvalid?d:null,n].filter(Boolean).join(" ")||void 0}}}function we(e={}){let[a,t]=ue(e.value,e.defaultValue||[],e.onChange),r=!!e.isRequired&&a.length===0,l=b.useRef(new Map),n=O({...e,value:a}),d=n.displayValidation.isInvalid;var o;return{...n,value:a,setValue(i){e.isReadOnly||e.isDisabled||t(i)},isDisabled:e.isDisabled||!1,isReadOnly:e.isReadOnly||!1,isSelected(i){return a.includes(i)},addValue(i){e.isReadOnly||e.isDisabled||a.includes(i)||t(a.concat(i))},removeValue(i){e.isReadOnly||e.isDisabled||a.includes(i)&&t(a.filter(c=>c!==i))},toggleValue(i){e.isReadOnly||e.isDisabled||(a.includes(i)?t(a.filter(c=>c!==i)):t(a.concat(i)))},setInvalid(i,c){let u=new Map(l.current);c.isInvalid?u.set(i,c):u.delete(i),l.current=u,n.updateValidation(fe(...u.values()))},validationState:(o=e.validationState)!==null&&o!==void 0?o:d?"invalid":null,isInvalid:d,isRequired:r}}var Ve="_1kcxloq0",_e="_1kcxloq1",Le="_1kcxloq2",Oe=Z({defaultClassName:"_1kcxloq3 tq83zq0",variantClassNames:{},defaultVariants:{},compoundVariants:[]}),Se="_1kcxloq4",Re=Z({defaultClassName:"_1kcxloq8 _1kcxloq7 onxwju6g onxwju58 onxwju3k onxwju8 onxwju14 onxwju40 _1kcxloq6 _1kcxloq5",variantClassNames:{},defaultVariants:{},compoundVariants:[]});const ie=e=>{const a=b.useRef(null),t=b.useContext(w),{inputProps:r,isSelected:l}=$e(e,t,a),{isFocusVisible:n,focusProps:d}=pe();return s.createElement("label",{className:Oe(),..._({"focus-visible":n})},s.createElement(ge,null,s.createElement("input",{...L(r,d),ref:a})),s.createElement("div",{className:ee({display:"flex",gap:"2",width:"100%"})},s.createElement("div",{className:Re(),..._({checked:l})},s.createElement(xe,{icon:Ie})),s.createElement("div",{className:Se},e.children)))};ie.displayName="OptionList.Item";const ne=({children:e,content:a})=>!e&&!a?null:s.createElement("div",{className:ee({display:"flex",gap:"2",justifyContent:"space-between"})},e??(a==null?void 0:a.map(t=>s.createElement("span",{key:t},t))));ne.displayName="OptionList.ItemSplitLabel";try{OptionList.Item.displayName="OptionList.Item",OptionList.Item.__docgenInfo={description:`The OptionListItem is used to populate OptionList. They are outlined with a large interactive area and flexible
label content layout.`,displayName:"OptionList.Item",props:{}}}catch{}const w=b.createContext(null),p=e=>{const{children:a,className:t,description:r,label:l,ref:n,style:d}=e,o={ref:n,className:t,style:d},m=we(e),{groupProps:i,labelProps:c,descriptionProps:u}=Ce(e,m);return s.createElement("div",{...i,...o,..._({"test-id":e.testId})},s.createElement("div",{...c,className:_e},l),r&&s.createElement("div",{...u,className:Le},r),s.createElement(w.Provider,{value:m},s.createElement("div",{className:Ve},a)))};p.Item=ie;p.ItemSplitLabel=ne;try{w.displayName="OptionListContext",w.__docgenInfo={description:"",displayName:"OptionListContext",props:{}}}catch{}try{p.displayName="OptionList",p.__docgenInfo={description:"The OptionList is a form control that groups selectable items that apear as an outlined list of options and\nimplements React Aria `useCheckboxGroup`\n([docs](https://react-spectrum.adobe.com/react-aria/useCheckboxGroup.html))\n\nPopulate the OptionList group with the OptionListList, each item must have a `value` (unique) and be labelled.\nThe `value` of all active items are passed as a string array to set `defaultValue` (uncontrolled), `value`\n(controlled) and is the format returned from the onChange handler as well.\n\nUsed in the booking flow on the payment step for addons.\nFuture enhancements might include: validation states/error handling",displayName:"OptionList",props:{label:{defaultValue:null,description:"Label for the CheckboxButtons group needs to be provided at the component level for accessibility",name:"label",required:!0,type:{name:"ReactNode"}},description:{defaultValue:null,description:"A description for the field. Provides a hint such as specific requirements for what to choose.",name:"description",required:!1,type:{name:"ReactNode"}},children:{defaultValue:null,description:"Populate with one or more CheckboxItem components",name:"children",required:!1,type:{name:"ReactNode"}},name:{defaultValue:null,description:"The name of the input element, used when submitting an HTML form. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#htmlattrdefname).",name:"name",required:!1,type:{name:"string"}},defaultValue:{defaultValue:null,description:"The default value (uncontrolled).",name:"defaultValue",required:!1,type:{name:"string[]"}},value:{defaultValue:null,description:"Current selected value (controlled state)",name:"value",required:!1,type:{name:"string[]"}},onChange:{defaultValue:null,description:`Event handler when any checkbox button changes. Returned string array is the values of the inputs that are currently
checked.`,name:"onChange",required:!1,type:{name:"((value: string[]) => void)"}},testId:{defaultValue:null,description:"The test ID will be rendered as a data attribute on the element for e2e testing purposes",name:"testId",required:!1,type:{name:"string"}}}}}catch{}try{p.Item.displayName="OptionList.Item",p.Item.__docgenInfo={description:`The OptionListItem is used to populate OptionList. They are outlined with a large interactive area and flexible
label content layout.`,displayName:"OptionList.Item",props:{}}}catch{}try{p.ItemSplitLabel.displayName="OptionList.ItemSplitLabel",p.ItemSplitLabel.__docgenInfo={description:"Helper component part to display a checkbox button label with a second column justified to the end",displayName:"OptionList.ItemSplitLabel",props:{content:{defaultValue:null,description:"convenience prop for passing through a string array instead of children",name:"content",required:!1,type:{name:"string[]"}}}}}catch{}const V=[["Tyre puncture repair","+28.00"],["Roadworthy certificate","+89.85"],["Re-gas air-conditioning","+99.00"],["Windscreen wipers - pair","+45.92"]],Ee={title:"Forms & Input Fields/Option List",component:p,args:{label:"Commonly requested extras",name:"extras",children:V.map((e,a)=>s.createElement(p.Item,{key:a,value:`${a}`},e[0])),testId:"demo-option-list",onChange:Y()},tags:["beta"]},k={play:async({args:e,canvasElement:a,step:t})=>{const l=le(a).getAllByRole("group")[0],n=se(l,"checkbox");await t("Group renders label and attributes",async()=>{await h(l.firstChild).toHaveTextContent(`${e.label}`),await h(l).toHaveAttribute("data-test-id",e.testId)}),await t("Checkboxes render labels and attributes",async()=>{for(const[d,o]of n.entries()){const m=o.closest("label");await h(m).toHaveTextContent(V[d][0]),await h(o).not.toBeChecked(),await h(o).toHaveAttribute("name",e.name),await h(o).toHaveAttribute("value",`${d}`)}}),await t("Checked states and onChange event",async()=>{for(const d of[0,2]){const o=n[d];await R.click(o,{delay:25}),await h(e.onChange).toHaveBeenCalled(),await h(o).toBeChecked()}}),await t("Keyboard interaction",async()=>{await R.keyboard("{Shift>}[Tab][Tab]{/Shift}[Space][Tab][Tab][Space]",{delay:25}),await h(e.onChange).toHaveBeenCalled(),await h(n[0]).not.toBeChecked(),await h(n[2]).not.toBeChecked()})}},g={args:{children:V.map((e,a)=>s.createElement(p.Item,{key:a,value:`${a}`},s.createElement(p.ItemSplitLabel,{content:e})))}},C={args:{...g.args,defaultValue:["1"]}},$={render:()=>{var r;const[e,a]=b.useState(["0","1","2","3"]),t=l=>{a(l),Y()};return s.createElement(p,{label:(r=Ee.args)==null?void 0:r.label,onChange:t,value:e},V.map((l,n)=>s.createElement(p.Item,{key:n,value:`${n}`},s.createElement(p.ItemSplitLabel,{content:l}))))}};var E,P,q,B,D;k.parameters={...k.parameters,docs:{...(E=k.parameters)==null?void 0:E.docs,source:{originalSource:`{
  play: async ({
    args,
    canvasElement,
    step
  }) => {
    const canvas = within(canvasElement);
    const group = canvas.getAllByRole('group')[0];
    const checkboxes = getAllByRole(group, 'checkbox');
    await step('Group renders label and attributes', async () => {
      await expect(group.firstChild).toHaveTextContent(\`\${args.label}\`);
      await expect(group).toHaveAttribute('data-test-id', args.testId);
    });
    await step('Checkboxes render labels and attributes', async () => {
      for (const [idx, checkbox] of checkboxes.entries()) {
        const label = checkbox.closest('label');
        await expect(label).toHaveTextContent(itemData[idx][0]);
        await expect(checkbox).not.toBeChecked();
        await expect(checkbox).toHaveAttribute('name', args.name);
        await expect(checkbox).toHaveAttribute('value', \`\${idx}\`);
      }
    });
    await step('Checked states and onChange event', async () => {
      for (const idx of [0, 2]) {
        const checkbox = checkboxes[idx];
        await userEvent.click(checkbox, {
          delay: 25
        });
        await expect(args.onChange).toHaveBeenCalled();
        await expect(checkbox).toBeChecked();
      }
    });
    await step('Keyboard interaction', async () => {
      await userEvent.keyboard('{Shift>}[Tab][Tab]{/Shift}[Space][Tab][Tab][Space]', {
        delay: 25
      });
      await expect(args.onChange).toHaveBeenCalled();
      await expect(checkboxes[0]).not.toBeChecked();
      await expect(checkboxes[2]).not.toBeChecked();
    });
  }
}`,...(q=(P=k.parameters)==null?void 0:P.docs)==null?void 0:q.source},description:{story:"For simple content, map through the options, e.g.\n\n```\nitemData.map((item, idx) => (\n  <CheckboxButtons.Item key={idx} value={`${idx}`}>\n    {item[0]}\n  </CheckboxButtons.Item>\n))\n```",...(D=(B=k.parameters)==null?void 0:B.docs)==null?void 0:D.description}}};var N,T,H,A,M;g.parameters={...g.parameters,docs:{...(N=g.parameters)==null?void 0:N.docs,source:{originalSource:`{
  args: {
    children: itemData.map((data, idx) => <OptionList.Item key={idx} value={\`\${idx}\`}>
                <OptionList.ItemSplitLabel content={data} />
            </OptionList.Item>)
  }
}`,...(H=(T=g.parameters)==null?void 0:T.docs)==null?void 0:H.source},description:{story:"To acheive the the split-column layout in the checkbox label, use a CheckboxButtons.SplitLabel layout helper\ninside the CheckboxButtons.Item component. Currently supports text only. Populate the `content` prop on the SplitLabel\nwith a string array (content left, content right).",...(M=(A=g.parameters)==null?void 0:A.docs)==null?void 0:M.description}}};var F,j,W,G,z;C.parameters={...C.parameters,docs:{...(F=C.parameters)==null?void 0:F.docs,source:{originalSource:`{
  args: {
    ...SplitLabel.args,
    defaultValue: ['1']
  }
}`,...(W=(j=C.parameters)==null?void 0:j.docs)==null?void 0:W.source},description:{story:"The second option is checked by default, but the inputs are uncontrolled.",...(z=(G=C.parameters)==null?void 0:G.docs)==null?void 0:z.description}}};var K,U,J,Q,X;$.parameters={...$.parameters,docs:{...(K=$.parameters)==null?void 0:K.docs,source:{originalSource:`{
  render: () => {
    const [currentValue, setCurrentValue] = useState<string[]>(['0', '1', '2', '3']);
    const handleOnChange = (values: string[]) => {
      setCurrentValue(values);
      fn();
    };
    return <OptionList label={meta.args?.label} onChange={handleOnChange} value={currentValue}>
                {itemData.map((data, idx) => <OptionList.Item key={idx} value={\`\${idx}\`}>
                        <OptionList.ItemSplitLabel content={data} />
                    </OptionList.Item>)}
            </OptionList>;
  }
}`,...(J=(U=$.parameters)==null?void 0:U.docs)==null?void 0:J.source},description:{story:`Controlled state with onChange handler. Each checkbox item must have a unique value because the state is handled as
an array of the selected values.`,...(X=(Q=$.parameters)==null?void 0:Q.docs)==null?void 0:X.description}}};const Xe=["Simple","SplitLabel","DefaultChecked","Controlled"];export{$ as Controlled,C as DefaultChecked,k as Simple,g as SplitLabel,Xe as __namedExportsOrder,Ee as default};
